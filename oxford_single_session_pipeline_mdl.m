%% Oxford Single-Session CCA Analysis Pipeline (MDL Format)
%
% This script implements the complete single-session CCA analysis pipeline
% for the updated Oxford dataset format using MDL (Model Data Layer) files.
%
% KEY CHANGES FROM ORIGINAL PIPELINE:
% =====================================
% 1. DATA SOURCE: Downloads {session}.mdl.mat instead of {session}.cue_dlc_bar_off.trial.mat
%    - MDL files contain continuous firing rates in mdl.predictor.firing_rate
%    - Data format: [N_neurons × T_total] without trial structure
%
% 2. TRIAL SEGMENTATION: Uses t_approach table for behavioral alignment
%    - Filters for label == 'cued hit long' trials only
%    - Time window: [-1.5s, +3.0s] → bins [start_bin - 75, start_bin + 150]
%    - Assumes 50Hz (20ms) binning in MDL data
%
% 3. CLEANUP: Removes both MDL and cell_metrics files after each session
%    - {session}.mdl.mat deleted after processing
%    - {session}_npxX.cell_metrics.cellinfo.mat files deleted
%
% t_approach TABLE STRUCTURE:
% ===========================
% The t_approach table is generated by get_tapproach.m from global_movement-master_test/extract
% Required columns:
%   - Column 1-3: animal_id, session_date, session_name (session identifiers)
%   - start_time: alignment time in bins (at 50Hz)
%   - label: trial type label ("cued hit long", "other", "spont short")
%
% MATHEMATICAL FRAMEWORK:
% =======================
% The continuous firing rate matrix F ∈ ℝ^{N×T} is transformed to trial structure:
%
%   F_trial(k) = F[:, τ_k - 75 : τ_k + 150]
%
% where τ_k is the start_time bin for trial k with label 'cued hit long'.
% This yields a tensor F_trials ∈ ℝ^{K × N × 226} where:
%   - K = number of valid trials
%   - N = number of neurons
%   - 226 = time bins (75 pre + 1 align + 150 post)

clear; clc;
fprintf('═══════════════════════════════════════════════════════════════════\n');
fprintf('  Oxford Single-Session CCA Analysis Pipeline (MDL Format)\n');
fprintf('═══════════════════════════════════════════════════════════════════\n\n');

%% Configuration Phase
% Define experimental parameters for data acquisition and analysis

% Server Configuration for HPC Data Acquisition
server_config = struct();
server_config.host = 'hpc-login-1.cubi.bihealth.org';
server_config.username = 'shca10_c';  % Replace with your credentials
server_config.base_dir = '/data/cephfs-2/unmirrored/groups/peng/YP_Oxford/';

% Analysis Configuration
analysis_config = struct();
analysis_config.local_base_dir = '/Users/shengyuancai/Downloads/Oxford_dataset/';
analysis_config.min_neurons_per_region = 100;    % Minimum for statistical reliability
analysis_config.target_neurons = analysis_config.min_neurons_per_region;            % Standardized count for fair comparison
analysis_config.time_window = [-1.5, 3.0];      % Time window (seconds)
analysis_config.n_components = 10;               % Maximum canonical components
analysis_config.cv_folds = 10;                  % Cross-validation folds
analysis_config.significance_threshold = 50;   % Percentile threshold

fprintf('Configuration:\n');
fprintf('  Server: %s\n', server_config.host);
fprintf('  Local storage: %s\n', analysis_config.local_base_dir);
fprintf('  Neuron threshold: %d per region\n', analysis_config.min_neurons_per_region);
fprintf('  Time window: [%.1f, %.1f] seconds\n', ...
        analysis_config.time_window(1), analysis_config.time_window(2));

%% Load t_approach Table
% The t_approach table contains behavioral timestamps for trial alignment
% Generated by get_tapproach.m from global_movement-master_test/extract

fprintf('\nLoading t_approach table...\n');

% Specify path to t_approach file
t_approach_file = fullfile(analysis_config.local_base_dir, 'tapproach_global_oyku.mat');

if ~exist(t_approach_file, 'file')
    error(['t_approach file not found: %s\n' ...
           'Please ensure the t_approach.mat file is in the local_base_dir.\n' ...
           'This file should be generated by get_tapproach.m from ' ...
           'global_movement-master_test/extract'], t_approach_file);
end

% Load and validate t_approach
t_approach_data = load(t_approach_file);

% Handle different possible variable names in the .mat file
if isfield(t_approach_data, 't_approach')
    t_approach = t_approach_data.t_approach;
elseif isfield(t_approach_data, 'T_approach')
    t_approach = t_approach_data.T_approach;
else
    % Assume first table variable is t_approach
    field_names = fieldnames(t_approach_data);
    for i = 1:length(field_names)
        if istable(t_approach_data.(field_names{i}))
            t_approach = t_approach_data.(field_names{i});
            break;
        end
    end
end

if ~istable(t_approach)
    error('Could not load t_approach as a table');
end

% Validate required columns
required_columns = {'start_time', 'label'};
missing_cols = setdiff(required_columns, t_approach.Properties.VariableNames);
if ~isempty(missing_cols)
    error('t_approach missing required columns: %s', strjoin(missing_cols, ', '));
end

fprintf('  Loaded t_approach: %d rows, %d columns\n', height(t_approach), width(t_approach));
fprintf('  Columns: %s\n', strjoin(t_approach.Properties.VariableNames, ', '));

% Display label distribution
if ismember('label', t_approach.Properties.VariableNames)
    label_counts = groupcounts(t_approach, 'label');
    fprintf('  Label distribution:\n');
    for i = 1:height(label_counts)
        fprintf('    %s: %d trials\n', string(label_counts.label(i)), label_counts.GroupCount(i));
    end
end

%% Session Definition
% Define experimental sessions to process
% session_list = {
% {'yp013', '220211'}};
session_list = {
    {'yp010', '220209'}, 
    {'yp010', '220210'}, 
    {'yp010', '220211'}, 
    {'yp010', '220212'},
    {'yp012', '220208'}, 
    {'yp012', '220209'}, 
    {'yp012', '220210'}, 
    {'yp012', '220211'}, 
    {'yp012', '220212'}, 
    {'yp013', '220209'}, 
    {'yp013', '220210'}, 
    {'yp013', '220211'}, 
    {'yp013', '220212'},
    {'yp014', '220208'}, 
    {'yp014', '220209'}, 
    {'yp014', '220210'}, 
    {'yp014', '220211'}, 
    {'yp014', '220212'},
    {'yp020', '220331'}, 
    {'yp020', '220401'}, 
    {'yp020', '220402'}, 
    {'yp020', '220403'}, 
    {'yp020', '220404'}, 
    {'yp020', '220405'}, 
    {'yp020', '220407'}, 
    {'yp021', '220331'}, 
    {'yp021', '220401'}, 
    {'yp021', '220402'}, 
    {'yp021', '220403'}, 
    {'yp021', '220404'}, 
    {'yp021', '220405'}, 
    {'yp021', '220407'}, 
    {'yp022', '220401'}, 
    {'yp022', '220402'}, 
    {'yp022', '220403'}, 
    {'yp022', '220404'}, 
    {'yp022', '220405'}, 
    {'yp022', '220407'}
};

fprintf('\nSession queue:\n');
for i = 1:length(session_list)
    session_info = session_list{i};
    fprintf('  %d. %s_%s\n', i, session_info{1}, session_info{2});
end
fprintf('Total sessions: %d\n', length(session_list));

%% Pre-Analysis Validation

fprintf('\nValidating pipeline components...\n');

% Ensure local directories exist
if ~exist(analysis_config.local_base_dir, 'dir')
    mkdir(analysis_config.local_base_dir);
    fprintf('  Created local base directory\n');
end

% Validate required functions are in path
required_functions = {
    'download_oxford_mdl_data', ...       % New MDL download function
    'segment_mdl_to_trials', ...          % New trial segmentation function
    'extract_session_data_mdl', ...       % New MDL extraction function
    'cleanup_session_mdl_files', ...      % New cleanup function
    'single_session_oxford_CCA_mdl', ...  % Updated main pipeline function
    'perform_region_pca', ...             % Existing PCA function
    'perform_session_cca', ...            % Existing CCA function
    'save_session_results'                % Existing save function
};

missing_functions = {};
for i = 1:length(required_functions)
    if ~exist(required_functions{i}, 'file')
        missing_functions{end+1} = required_functions{i};
    end
end

if ~isempty(missing_functions)
    fprintf('  WARNING: Missing functions:\n');
    for i = 1:length(missing_functions)
        fprintf('    - %s\n', missing_functions{i});
    end
    fprintf('  Ensure all required functions are in MATLAB path.\n');
else
    fprintf('  All required functions found\n');
end

fprintf('  Validation complete\n');

%% Execute Pipeline

fprintf('\n');
fprintf('═══════════════════════════════════════════════════════════════════\n');
fprintf('  Beginning Pipeline Execution\n');
fprintf('═══════════════════════════════════════════════════════════════════\n');

try
    % Execute the main pipeline function with t_approach
    single_session_oxford_CCA_mdl(session_list, server_config, analysis_config, t_approach);
    
    fprintf('\n✓ Pipeline execution completed successfully\n');
    
catch ME
    fprintf('\n✗ Pipeline execution failed\n');
    fprintf('Error: %s\n', ME.message);
    fprintf('Stack trace:\n');
    for i = 1:length(ME.stack)
        fprintf('  Line %d in %s: %s\n', ME.stack(i).line, ME.stack(i).name, ME.stack(i).file);
    end
    
    % % Attempt emergency cleanup
    % fprintf('\nAttempting emergency cleanup...\n');
    % try
    %     for i = 1:length(session_list)
    %         session_info = session_list{i};
    %         cleanup_session_mdl_files(session_info{1}, session_info{2}, ...
    %                                   analysis_config.local_base_dir, false);
    %     end
    %     fprintf('  Emergency cleanup completed\n');
    % catch
    %     fprintf('  Emergency cleanup failed - manual intervention may be needed\n');
    % end
    
    rethrow(ME);
end

%% Post-Processing Validation

fprintf('\n');
fprintf('═══════════════════════════════════════════════════════════════════\n');
fprintf('  Post-Processing Validation\n');
fprintf('═══════════════════════════════════════════════════════════════════\n');

cca_results_dir = fullfile(analysis_config.local_base_dir, 'sessions_analysis_results');
%psth_results_dir = fullfile(analysis_config.local_base_dir, 'session_PSTH_results');

if exist(cca_results_dir, 'dir')
    cca_files = dir(fullfile(cca_results_dir, '*_CCA_results.mat'));
    %psth_files = dir(fullfile(psth_results_dir, '*_PSTH_data.mat'));
    
    fprintf('Results summary:\n');
    fprintf('  CCA result files: %d\n', length(cca_files));
    %fprintf('  PSTH result files: %d\n', length(psth_files));
    fprintf('  Expected files: %d (per type)\n', length(session_list));
    
    success_rate = (length(cca_files) / length(session_list)) * 100;
    fprintf('  Success rate: %.1f%%\n', success_rate);
    
    % Sample quality check
    if ~isempty(cca_files)
        fprintf('\nSample result examination:\n');
        sample_file = fullfile(cca_results_dir, cca_files(1).name);
        sample_data = load(sample_file);
        
        if isfield(sample_data, 'cca_summary')
            fprintf('  Session: %s\n', sample_data.cca_summary.session_name);
            fprintf('  Regions analyzed: %d\n', length(sample_data.cca_summary.valid_regions));
            fprintf('  Max R²: %.3f\n', sample_data.cca_summary.max_R2_across_pairs);
        end
    end
else
    fprintf('  Results directories not found\n');
end

%% Final Summary

fprintf('\n');
fprintf('═══════════════════════════════════════════════════════════════════\n');
fprintf('  Pipeline Complete\n');
fprintf('═══════════════════════════════════════════════════════════════════\n');
fprintf('Data format: MDL (continuous firing rates segmented via t_approach)\n');
fprintf('Trial selection: label == ''cued hit long''\n');
fprintf('Time window: [%.1f, %.1f] seconds → [%d, +%d] bins\n', ...
        analysis_config.time_window(1), analysis_config.time_window(2), -75, 150);
