%%
% =========================================================================
% MOp-FOCUSED GLM SENSITIVITY ANALYSIS - CORRECTED VERSION
% =========================================================================
% This version correctly interfaces with sensitivity results saved by
% oxford_GLM_sensitivity.m, which stores results as individual files
% (sensitivity_*.mat) rather than embedding them in all_glm_results.
%
% KEY ARCHITECTURAL CLARIFICATION:
% The sensitivity analysis pipeline follows a two-stage architecture:
% 1. oxford_GLM_sensitivity.m generates sensitivity_*.mat files
% 2. This script aggregates those files for MOp-specific visualization
%
% MATHEMATICAL FRAMEWORK:
% We quantify encoding concentration through $R^2$ degradation curves.
% Define $\mathcal{N}_\rho$ as the set of remaining neurons after removing
% proportion $\rho \in [0, 1]$ of top-ranked neurons. The concentration
% measure at threshold $\rho_0 = 0.5$ is:
%
% $$C = R^2(\mathcal{N}_0) - R^2(\mathcal{N}_{0.5})$$
%
% where $R^2(\mathcal{N})$ represents explained variance using neuron set $\mathcal{N}$.
% Lower $R^2(\mathcal{N}_{0.5})$ indicates higher concentration (steeper drop).
% =========================================================================
clc;clear all; close all;
%% Configuration
component_index = '01';
component = 1;

base_results_dir = '/Users/shengyuancai/Downloads/Oxford_dataset/';
component_to_analyze = 1;
glm_results_dir = fullfile(base_results_dir, sprintf('GLM_Analysis_Component_%d', component_to_analyze));
cca_results_dir = fullfile(base_results_dir, 'session_CCA_results');
output_dir = fullfile(glm_results_dir, 'sensitivity_analysis');

% Verify output directory exists
if ~exist(output_dir, 'dir')
    error('Sensitivity analysis directory not found. Run oxford_GLM_sensitivity.m first.');
end

% =========================================================================
% FUNCTION 1: MOp REGIONAL DROP HEATMAP (FILE-BASED VERSION)
% =========================================================================

function create_MOp_regional_drop_heatmap(output_dir)
% CREATE_MOp_REGIONAL_DROP_HEATMAP Creates asymmetric heatmap from sensitivity files
%
% CORRECTED DATA ACCESS:
% This function now correctly loads sensitivity_*.mat files generated by
% oxford_GLM_sensitivity.m rather than attempting to access a non-existent
% unified structure field.
%
% ASYMMETRIC HEATMAP INTERPRETATION:
% The matrix element $M_{ij}$ represents the encoding concentration of
% region $i$ when paired with region $j$. Since pairwise CCA is symmetric
% but neural encoding is not, we have $M_{ij} \neq M_{ji}$ in general.
%
% INPUTS:
%   output_dir - Directory containing sensitivity_*.mat files

    fprintf('Creating MOp-focused regional drop heatmap from sensitivity files...\n');
    
    % Define MOp target regions with consistent naming
    MOp_target_regions = {'mPFC', 'ORB ','STR', 'LP','MD'};
    
    % Include MOp itself for within-region analysis
    all_regions = ['MOp', MOp_target_regions];
    n_regions = length(all_regions);
    
    % Initialize concentration matrix with NaN for missing data
    % This maintains distinction between "zero concentration" and "no data"
    concentration_matrix = nan(n_regions, n_regions);
    
    % Load sensitivity analysis results from files
    sensitivity_files = dir(fullfile(output_dir, 'sensitivity_*.mat'));
    fprintf('Found %d sensitivity analysis files\n', length(sensitivity_files));
    
    if isempty(sensitivity_files)
        error('No sensitivity files found. Please run oxford_GLM_sensitivity.m first.');
    end
    
    % Process each sensitivity result file
    for f = 1:length(sensitivity_files)
        file_path = fullfile(output_dir, sensitivity_files(f).name);
        data = load(file_path);
        
        % Extract sensitivity_results structure
        % CRITICAL: This structure is created by oxford_GLM_sensitivity.m
        % and contains the fields: region1, region2, removal_percentages, sessions
        if ~isfield(data, 'sensitivity_results')
            fprintf('  Warning: File %s missing sensitivity_results field, skipping\n', ...
                sensitivity_files(f).name);
            continue;
        end
        
        sensitivity_results = data.sensitivity_results;
        
        % Apply minimum session threshold for statistical robustness
        % Rationale: Insufficient samples lead to unreliable concentration estimates
        if ~isfield(sensitivity_results, 'sessions') || ...
           length(sensitivity_results.sessions) < 2
            fprintf('  Skipping pair with insufficient sessions (<5)\n');
            continue;
        end
        
        % Extract region identifiers
        if ~isfield(sensitivity_results, 'region1') || ~isfield(sensitivity_results, 'region2')
            fprintf('  Warning: Missing region identifiers in %s\n', sensitivity_files(f).name);
            continue;
        end
        
        region1 = sensitivity_results.region1;
        region2 = sensitivity_results.region2;
        
        % Check if this pairing involves MOp and one of our target regions
        [is_MOp_pair, idx1, idx2] = check_MOp_pairing(region1, region2, all_regions);
        
        if ~is_MOp_pair
            continue; % Skip non-MOp pairings
        end
        
        % Find 50% removal index
        % This threshold balances sufficient ablation with adequate population size
        if ~isfield(sensitivity_results, 'removal_percentages')
            fprintf('  Warning: Missing removal_percentages in %s\n', sensitivity_files(f).name);
            continue;
        end
        
        removal_pct = sensitivity_results.removal_percentages;
        idx_50 = find(removal_pct >= 50, 1, 'first');
        
        if isempty(idx_50)
            fprintf('  Warning: No 50%% removal point found for %s vs %s\n', region1, region2);
            continue;
        end
        
        % Extract session-level concentration measurements
        % CORRECTED STRUCTURE ACCESS: Each session has region1_toprank and region2_toprank arrays
        n_sessions = length(sensitivity_results.sessions);
        region1_concentrations_50 = zeros(n_sessions, 1);
        region2_concentrations_50 = zeros(n_sessions, 1);
        
        for s = 1:n_sessions
            session = sensitivity_results.sessions{s};
            
            % Verify required fields exist
            if ~isfield(session, 'region1_toprank') || ~isfield(session, 'region2_toprank')
                fprintf('    Warning: Session %d missing toprank fields\n', s);
                continue;
            end
            
            % Extract R² at 50% removal (represents remaining explained variance)
            % Lower values indicate steeper drop from baseline, hence higher concentration
            region1_concentrations_50(s) = session.region1_toprank(idx_50);
            region2_concentrations_50(s) = session.region2_toprank(idx_50);
        end
        
        % Calculate mean encoding concentration across sessions
        % INTERPRETATION: Lower mean R² at 50% removal indicates more concentrated encoding
        region1_mean_concentration = mean(region1_concentrations_50);
        region2_mean_concentration = mean(region2_concentrations_50);
        
        % Store in asymmetric matrix
        % Position (idx1, idx2) receives region1's concentration when paired with region2
        % Position (idx2, idx1) receives region2's concentration when paired with region1
        concentration_matrix(idx1, idx2) = region1_mean_concentration;
        concentration_matrix(idx2, idx1) = region2_mean_concentration;
        
        fprintf('  Processed %s vs %s: concentrations = %.3f, %.3f (n=%d sessions)\n', ...
            region1, region2, region1_mean_concentration, region2_mean_concentration, n_sessions);
    end
    
    % Create publication-quality heatmap visualization
    figure('Position', [100, 100, 900, 800]);
    h = imagesc(concentration_matrix);
    
    % Configure NaN transparency for missing data visualization
    set(h, 'AlphaData', ~isnan(concentration_matrix));
    
    % Apply perceptually uniform colormap
    % Blue (high R² = low concentration) → Yellow → Red (low R² = high concentration)
    n_colors = 256;
    custom_colormap = [linspace(0.2, 1, n_colors)', ...
                       linspace(0.4, 0.2, n_colors)', ...
                       linspace(0.8, 0.2, n_colors)'];
    colormap(custom_colormap);
    
    % Set dynamic color axis based on actual data range
    valid_data = concentration_matrix(~isnan(concentration_matrix));
    if ~isempty(valid_data)
        caxis([min(valid_data), max(valid_data)]);
    end
    
    % Configure colorbar with scientific notation
    c = colorbar;
    c.Label.String = 'Mean R^2 at 50% Neuron Removal';
    c.Label.FontSize = 16;
    c.FontSize = 16;
    c.Label.Rotation = 90;
    c.Label.Position = [3.5 mean(c.Limits) 0];
    
    % Configure axis appearance
    ax = gca;
    ax.XAxisLocation = 'bottom';
    ax.YAxisLocation = 'left';
    set(gca, 'XTick', 1:n_regions);
    set(gca, 'YTick', 1:n_regions);
    
    % Create readable labels (replace underscores with spaces)
    clean_labels = cellfun(@(x) strrep(x, '_', ' '), all_regions, 'UniformOutput', false);
    set(gca, 'XTickLabel', clean_labels);
    set(gca, 'YTickLabel', clean_labels);
    set(gca, 'XTickLabelRotation', 45);
    set(gca, 'FontSize', 15);
    
    % Remove extraneous visual elements
    box off;
    ax.TickLength = [0 0];
    
    % Add value annotations to cells
    for i = 1:n_regions
        for j = 1:n_regions
            if ~isnan(concentration_matrix(i, j))
                text(j, i, sprintf('%.2f', concentration_matrix(i, j)), ...
                    'HorizontalAlignment', 'center', ...
                    'VerticalAlignment', 'middle', ...
                    'FontSize', 10, ...
                    'Color', 'white', ...
                    'FontWeight', 'bold');
            end
        end
    end
    
    % Add axis labels with scientific terminology
    xlabel('Paired Region', 'FontSize', 17, 'FontWeight', 'normal');
    ylabel('Source Region (Concentration Measured)', 'FontSize', 17, 'FontWeight', 'normal');
    title('MOp Pathway Encoding Concentration Analysis', ...
        'FontSize', 18, 'FontWeight', 'normal');
    
    % Ensure square aspect ratio for symmetric interpretation
    axis square;
    axis tight;
    set(gcf, 'Color', 'white');
    
    % Save in multiple formats for publication and analysis
    saveas(gcf, fullfile(output_dir, 'MOp_regional_drop_heatmap.png'));
    % saveas(gcf, fullfile(output_dir, 'MOp_regional_drop_heatmap.fig'));
    print(gcf, fullfile(output_dir, 'MOp_regional_drop_heatmap'), ...
          '-depsc', '-r300');
    
    % Save matrix for downstream statistical analysis
    save(fullfile(output_dir, 'MOp_concentration_matrix.mat'), ...
        'concentration_matrix', 'all_regions');
    
    fprintf('MOp regional heatmap saved to %s\n', output_dir);
    
    % Generate statistical summary
    fprintf('\n=== MOp Pathway Concentration Summary ===\n');
    fprintf('Mean concentration across all pathways: %.3f\n', mean(valid_data));
    fprintf('Highest concentration (lowest R² at 50%%): %.3f\n', min(valid_data));
    fprintf('Lowest concentration (highest R² at 50%%): %.3f\n', max(valid_data));
    
    % Identify pathways with MOpt concentrated encoding
    mean_concentration_per_region = mean(concentration_matrix, 2, 'omitnan');
    [~, sorted_idx] = sort(mean_concentration_per_region, 'ascend'); % Ascending: lower = more concentrated
    
    fprintf('\nRegions ranked by encoding concentration (MOpt to least concentrated):\n');
    for i = 1:n_regions
        if ~isnan(mean_concentration_per_region(sorted_idx(i)))
            fprintf('%d. %s (mean R² at 50%% = %.3f)\n', i, ...
                clean_labels{sorted_idx(i)}, ...
                mean_concentration_per_region(sorted_idx(i)));
        end
    end
end









% =========================================================================
% FUNCTION 2: MOp CONCENTRATION BAR PLOT (FILE-BASED VERSION)
% =========================================================================

function create_MOp_concentration_barplot(output_dir)
% CREATE_MOp_CONCENTRATION_BARPLOT Bar plot showing MOp pathway concentrations
%
% ORDERING APPROACH:
% Rather than sorting by concentration magnitude, we employ a canonical
% ordering defined by pathway_names_ref. This ensures consistent region
% presentation across all analyses and figures, facilitating systematic
% comparison of encoding patterns along the cortical hierarchy.
%
% The reference ordering typically reflects anatomical or functional
% organization (e.g., frontal → sensory → subcortical → thalamic).

    fprintf('Creating MOp pathway concentration bar plot from sensitivity files...\n');
    
    % =======================================================================
    % CANONICAL REGION ORDERING
    % =======================================================================
    % This reference list establishes the display order for all pathways.
    % Regions are arranged according to your standardized hierarchy.
    pathway_names_ref = {'mPFC', 'ORB', 'MOp', 'MOp', 'OLF', 'STR', ...
                        'STRv', 'HIPP', 'MD', 'LP', 'VALVM', 'VPMPO', ...
                        'ILM', 'HY', 'fiber', 'other'};
    
    % =======================================================================
    % DEFINE MOp TARGET PATHWAYS
    % =======================================================================
    % Column 1: Full pathway identifier (used for file matching)
    % Column 2: Target region name (used for display and ordering)
    MOp_pathways = {'MOp_ORB',  'ORB'; ...
                    'MOp_mPFC', 'mPFC'; ...
                    'MOp_MOp',  'MOp'; ...
                    'MOp_STR',  'STR'; ...
                    'LP_MOp',   'LP'; ...
                    'MD_MOp',   'MD'};
    
    n_pathways = size(MOp_pathways, 1);
    
    % Initialize storage for session-level measurements
    pathway_session_concentrations = cell(n_pathways, 1);
    pathway_names = MOp_pathways(:, 2);
    
    % =======================================================================
    % COMPUTE CANONICAL SORT ORDER
    % =======================================================================
    % For each pathway, determine its position in the reference list.
    % This creates a mapping: pathway index → reference position
    pathway_ref_indices = zeros(n_pathways, 1);
    
    for p = 1:n_pathways
        target_region = pathway_names{p};
        
        % Find position in reference list (case-insensitive matching)
        ref_idx = find(strcmpi(pathway_names_ref, target_region), 1);
        
        if ~isempty(ref_idx)
            pathway_ref_indices(p) = ref_idx;
        else
            % If region not found in reference, assign to end
            % This handles unexpected regions gracefully
            pathway_ref_indices(p) = length(pathway_names_ref) + p;
            warning('Region "%s" not found in reference list. Appending to end.', target_region);
        end
    end
    
    % Generate sort order based on reference positions
    % This gives us indices that will arrange pathways according to
    % their canonical anatomical/functional ordering
    [~, sort_order] = sort(pathway_ref_indices, 'ascend');
    
    fprintf('Canonical pathway ordering established:\n');
    for i = 1:n_pathways
        fprintf('  %d. %s (ref position: %d)\n', ...
            i, pathway_names{sort_order(i)}, pathway_ref_indices(sort_order(i)));
    end
    
    % =======================================================================
    % LOAD AND PROCESS SENSITIVITY FILES
    % =======================================================================
    sensitivity_files = dir(fullfile(output_dir, 'sensitivity_*.mat'));
    fprintf('Processing %d sensitivity files\n', length(sensitivity_files));
    
    for f = 1:length(sensitivity_files)
        file_path = fullfile(output_dir, sensitivity_files(f).name);
        data = load(file_path);
        
        if ~isfield(data, 'sensitivity_results')
            continue;
        end
        
        sensitivity_results = data.sensitivity_results;
        
        % Apply session count threshold for statistical reliability
        if ~isfield(sensitivity_results, 'sessions') || ...
           length(sensitivity_results.sessions) < 2
            continue;
        end
        
        % Extract region identifiers
        if ~isfield(sensitivity_results, 'region1') || ...
           ~isfield(sensitivity_results, 'region2')
            continue;
        end
        
        region1 = sensitivity_results.region1;
        region2 = sensitivity_results.region2;
        
        % Identify which MOp pathway this file represents
        pathway_idx = find_MOp_pathway_index(region1, region2, MOp_pathways);
        
        if isempty(pathway_idx)
            continue;
        end
        
        % Determine which region is MOp for correct data extraction
        is_MOp_region1 = contains(region1, 'MOp', 'IgnoreCase', true);
        
        % Locate the 50% removal threshold
        if ~isfield(sensitivity_results, 'removal_percentages')
            continue;
        end
        
        removal_pct = sensitivity_results.removal_percentages;
        idx_50 = find(removal_pct >= 50, 1, 'first');
        
        if isempty(idx_50)
            continue;
        end
        
        % Extract MOp concentration from each session
        for s = 1:length(sensitivity_results.sessions)
            session = sensitivity_results.sessions{s};
            
            if ~isfield(session, 'region1_toprank') || ...
               ~isfield(session, 'region2_toprank')
                continue;
            end
            
            % Extract MOp concentration based on region position
            if is_MOp_region1
                MOp_concentration = session.region1_toprank(idx_50);
            else
                MOp_concentration = session.region2_toprank(idx_50);
            end
            
            % Accumulate session-level observations
            pathway_session_concentrations{pathway_idx}(end+1) = MOp_concentration;
        end
    end
    
    % =======================================================================
    % COMPUTE SUMMARY STATISTICS
    % =======================================================================
    mean_concentrations = zeros(n_pathways, 1);
    std_concentrations = zeros(n_pathways, 1);
    n_observations = zeros(n_pathways, 1);
    
    for p = 1:n_pathways
        if ~isempty(pathway_session_concentrations{p})
            mean_concentrations(p) = mean(pathway_session_concentrations{p});
            std_concentrations(p) = std(pathway_session_concentrations{p});
            n_observations(p) = length(pathway_session_concentrations{p});
        end
    end
    
    % =======================================================================
    % CREATE VISUALIZATION WITH CANONICAL ORDERING
    % =======================================================================
    figure('Position', [100, 100, 600, 900]);
    
    % Note: sort_order now reflects canonical reference ordering,
    % not data-driven concentration ordering
    bar_handle = bar(mean_concentrations(sort_order), ...
        'FaceColor', [0.3, 0.5, 0.8], 'EdgeColor', 'none');
    hold on;
    
    % Add error bars representing inter-session variability
    errorbar(1:n_pathways, mean_concentrations(sort_order), ...
        std_concentrations(sort_order), ...
        'k', 'LineStyle', 'none', 'LineWidth', 2, 'CapSize', 10);
    
    % Apply functional color coding
    bar_handle.FaceColor = 'flat';
    for i = 1:n_pathways
        pathway_name = pathway_names{sort_order(i)};
        bar_handle.CData(i, :) = get_pathway_color(pathway_name);
    end
    
    % Overlay individual session observations as jittered points
    for i = 1:n_pathways
        pathway_idx = sort_order(i);
        if ~isempty(pathway_session_concentrations{pathway_idx})
            session_values = pathway_session_concentrations{pathway_idx};
            x_positions = i * ones(size(session_values)) + ...
                (rand(size(session_values)) - 0.5) * 0.2;
            scatter(x_positions, session_values, 20, 'k', ...
                'filled', 'MarkerFaceAlpha', 0.3);
        end
    end
    
    % Configure axis properties
    set(gca, 'XTick', 1:n_pathways);
    set(gca, 'XTickLabel', pathway_names(sort_order));
    set(gca, 'XTickLabelRotation', 45);
    set(gca, 'FontSize', 15);
    
    xlabel('MOp Target Region', 'FontSize', 17, 'FontWeight', 'normal');
    % ylabel('$R^2$ at 50\% Neuron Removal', 'FontSize', 17, ...
    %     'FontWeight', 'normal', 'Interpreter', 'latex');
    ylabel('R2 at 50% Neuron Removal', 'FontSize', 17, ...
        'FontWeight', 'normal');
    title('MOp Pathway Encoding Concentration', 'FontSize', 17, ...
        'FontWeight', 'normal');
    
    grid on;
    ax = gca;
    ax.Box = 'off';
    
    % Add value annotations above bars
    for i = 1:n_pathways
        idx = sort_order(i);
        if n_observations(idx) > 0
            text(i, mean_concentrations(idx) + std_concentrations(idx) + 0.03, ...
                sprintf('%.3f', mean_concentrations(idx)), ...
                'HorizontalAlignment', 'center', ...
                'FontSize', 15, 'FontWeight', 'normal');
        end
    end
    
    % Add sample size annotations at base of bars
    for i = 1:n_pathways
        idx = sort_order(i);
        text(i, 0.001, sprintf('n=%d', n_observations(idx)), ...
            'HorizontalAlignment', 'center', ...
            'VerticalAlignment', 'bottom', ...
            'FontSize', 15, 'Color', [0, 0, 0]);
    end
    
    ylim([0, max(mean_concentrations + std_concentrations) * 1.15]);
    
    % =======================================================================
    % SAVE OUTPUTS
    % =======================================================================
    saveas(gcf, fullfile(output_dir, 'MOp_concentration_barplot.png'));
    
    % Include sort_order and reference list in saved data for reproducibility
    save(fullfile(output_dir, 'MOp_pathway_concentration_data.mat'), ...
        'pathway_session_concentrations', 'pathway_names', 'mean_concentrations', ...
        'std_concentrations', 'n_observations', 'sort_order', 'pathway_names_ref');
    
    fprintf('MOp concentration bar plot saved to %s\n', output_dir);
    fprintf('Pathways displayed in canonical reference order.\n');
end









% =========================================================================
% FUNCTION 3: MOp PATHWAY PAIRED BOXPLOT (FILE-BASED VERSION)
% =========================================================================
%%
function create_MOp_pathway_boxplot(output_dir)
% CREATE_MOp_PATHWAY_BOXPLOT Paired boxplot comparing MOp with target regions
%
% CORRECTED PAIRED ANALYSIS:
% This function now properly extracts paired observations from the same
% sessions, enabling rigorous within-session comparisons that control for
% behavioral and physiological variability.
%
% STATISTICAL TEST:
% We employ the Wilcoxon signed-rank test for paired non-parametric data:
% $$H_0: \text{median}(R^2_{\text{MOp}} - R^2_{\text{target}}) = 0$$
%
% This tests whether MOp systematically exhibits different encoding
% concentration compared to its target regions.

    fprintf('Creating MOp pathway paired boxplot from sensitivity files...\n');
    
    MOp_pathways = {'MOp_ORB', 'mPFC'; ...
                    'MOp_mPFC', 'ORB';...
                    'MOp_MOp', 'MOp'; ...
                    'MOp_STR', 'STR'; ...
                    'LP_MOp', 'LP';...
                    'MD_MOp','MD'};
    
    n_pathways = size(MOp_pathways, 1);
    
    % Initialize Map container for efficient paired data storage
    pathway_session_data = containers.Map();
    
    % Load sensitivity files
    sensitivity_files = dir(fullfile(output_dir, 'sensitivity_*.mat'));
    % for index = i:length(MOp_pathways)

    for f = 1:length(sensitivity_files)
        file_path = fullfile(output_dir, sensitivity_files(f).name);
        data = load(file_path);
        
        if ~isfield(data, 'sensitivity_results')
            continue;
        end
        
        sensitivity_results = data.sensitivity_results;
        
        if ~isfield(sensitivity_results, 'sessions') || ...
           length(sensitivity_results.sessions) < 2
            continue;
        end
        
        % Extract region identifiers
        if ~isfield(sensitivity_results, 'region1') || ~isfield(sensitivity_results, 'region2')
            continue;
        end
        
        region1 = sensitivity_results.region1;
        region2 = sensitivity_results.region2;
        
        % Identify pathway
        pathway_idx = find_MOp_pathway_index(region1, region2, MOp_pathways);
        if isempty(pathway_idx)
            continue;
        end
        
        pathway_name = MOp_pathways{pathway_idx, 2};
        
        % Determine MOp position for correct pairing
        is_MOp_region1 = contains(region1, 'MOp', 'IgnoreCase', true);
        
        % Extract paired session data
        if ~isfield(sensitivity_results, 'removal_percentages')
            continue;
        end
        
        removal_pct = sensitivity_results.removal_percentages;
        idx_50 = find(removal_pct >= 50, 1, 'first');
        
        if isempty(idx_50)
            continue;
        end
        
        for s = 1:length(sensitivity_results.sessions)
            session = sensitivity_results.sessions{s};
            
            if ~isfield(session, 'region1_toprank') || ~isfield(session, 'region2_toprank')
                continue;
            end
            
            % Extract paired observations from the same session
            % This is CRITICAL for proper within-session comparison
            if is_MOp_region1
                MOp_concentration = session.region1_toprank(idx_50);
                target_concentration = session.region2_toprank(idx_50);
            else
                MOp_concentration = session.region2_toprank(idx_50);
                target_concentration = session.region1_toprank(idx_50);
            end
            
            % Create comprehensive session data structure
            session_data = struct();
            session_data.MOp_concentration = MOp_concentration;
            session_data.target_concentration = target_concentration;
            session_data.session_id = sprintf('file%d_s%d', f, s);
            
            % Accumulate paired data
            if isKey(pathway_session_data, pathway_name)
                pathway_session_data(pathway_name) = ...
                    [pathway_session_data(pathway_name); session_data];
            else
                pathway_session_data(pathway_name) = session_data;
            end
        end
    end
    
    % Extract discovered pathways
% Extract discovered pathways
    pathway_names = keys(pathway_session_data);
    
    % Define canonical ordering based on neuroanatomical hierarchy
    % This ordering typically reflects rostral-to-caudal organization
    % or functional groupings within the motor cortex pathway system
    pathway_names_ref = {'mPFC','ORB','MOp','MOp','OLF','STR','STRv',...
                         'HIPP','MD','LP','VALVM','VPMPO','ILM','HY',...
                         'fiber','other'};
    
    % Sort pathways according to reference ordering
    % For each discovered pathway, find its index in the reference list
    % Pathways not in reference list are appended at the end
    pathway_order_indices = zeros(1, length(pathway_names));
    
    for i = 1:length(pathway_names)
        ref_idx = find(strcmp(pathway_names_ref, pathway_names{i}), 1);
        if ~isempty(ref_idx)
            pathway_order_indices(i) = ref_idx;
        else
            % Assign large index for pathways not in reference
            % This places them at the end while preserving relative order
            pathway_order_indices(i) = length(pathway_names_ref) + i;
        end
    end
    
    % Sort pathway names by their reference indices
    [~, sort_idx] = sort(pathway_order_indices);
    pathway_names = pathway_names(sort_idx);
    
    n_pathways_found = length(pathway_names);


    
    
    if n_pathways_found == 0
        fprintf('Warning: No MOp pathway data found in sensitivity files.\n');
        return;
    end
    
    fprintf('Found data for %d MOp pathways: %s\n', ...
        n_pathways_found, strjoin(pathway_names, ', '));
    
    % Create visualization
    fig_width = max(700, 200 + n_pathways_found * 250);
    figure('Position', [100, 100, fig_width, 800]);
    
    % Initialize plotting data structures
    all_concentrations = [];
    group_labels = [];
    region_colors = [];
    pathway_stats = struct();

    % Process each pathway for statistical analysis and visualization
    for p = 1:n_pathways_found
        pathway_name = pathway_names{p};
        pathway_data = pathway_session_data(pathway_name);
        n_sessions = length(pathway_data);
        
        fprintf('Processing %s: %d sessions\n', pathway_name, n_sessions);
        
        % Extract paired data arrays
        MOp_concentrations = [pathway_data.MOp_concentration];
        target_concentrations = [pathway_data.target_concentration];
        
        % Organize for boxplot (MOp first, then target)
        MOp_position = 2*p - 1;
        target_position = 2*p;
        
        all_concentrations = [all_concentrations, MOp_concentrations, target_concentrations];
        group_labels = [group_labels, MOp_position*ones(1, n_sessions), target_position*ones(1, n_sessions)];
        
        % Apply consistent color scheme
        MOp_color = [0.2, 0.2, 0.8];
        target_color = get_pathway_color(pathway_name);
        region_colors = [region_colors; MOp_color; target_color];
        
        % Perform paired non-parametric statistical test
        % Wilcoxon signed-rank test is appropriate for paired non-normal data
        [p_value, ~] = signrank(MOp_concentrations, target_concentrations);
        
        % Calculate effect size using median difference
        median_difference = median(MOp_concentrations - target_concentrations);
        
        % Store comprehensive statistics
        pathway_stats.(sprintf('pathway_%d', p)) = struct();
        pathway_stats.(sprintf('pathway_%d', p)).name = pathway_name;
        pathway_stats.(sprintf('pathway_%d', p)).n_sessions = n_sessions;
        pathway_stats.(sprintf('pathway_%d', p)).MOp_mean = mean(MOp_concentrations);
        pathway_stats.(sprintf('pathway_%d', p)).MOp_std = std(MOp_concentrations);
        pathway_stats.(sprintf('pathway_%d', p)).MOp_median = median(MOp_concentrations);
        pathway_stats.(sprintf('pathway_%d', p)).target_mean = mean(target_concentrations);
        pathway_stats.(sprintf('pathway_%d', p)).target_std = std(target_concentrations);
        pathway_stats.(sprintf('pathway_%d', p)).target_median = median(target_concentrations);
        pathway_stats.(sprintf('pathway_%d', p)).p_value = p_value;
        pathway_stats.(sprintf('pathway_%d', p)).median_difference = median_difference;
    end
    
    % Create paired boxplot with connecting lines
    x_labels = {};
    for p = 1:n_pathways_found
        x_labels{end+1} = 'MOp';
        x_labels{end+1} = pathway_names{p};
    end
    
    h = boxplot(all_concentrations, group_labels, ...
        'Labels', x_labels, ...
        'Colors', region_colors, ...
        'Symbol', 'o', ...
        'OutlierSize', 5);
    set(h, 'LineWidth', 1.8);
    hold on;
    
    % Add individual points and connecting lines for paired observations
    jitter_amount = 0.12;
    % pathway_session_data
    % for ref_index = 1:length(pathway_names_ref)
    %     pathway_ref = pathway_names_ref{ref_index};
    for p = 1:n_pathways_found
        pathway_name = pathway_names{p};
        pathway_data = pathway_session_data(pathway_name);
        n_sessions = length(pathway_data);
        
        MOp_concentrations = [pathway_data.MOp_concentration];
        target_concentrations = [pathway_data.target_concentration];
        
        MOp_pos = 2*p - 1;
        target_pos = 2*p;
        
        for i = 1:n_sessions
            x1 = MOp_pos + (rand - 0.5) * jitter_amount;
            x2 = target_pos + (rand - 0.5) * jitter_amount;
            
            scatter(x1, MOp_concentrations(i), 35, [0.2, 0.2, 0.8], ...
                'filled', 'MarkerFaceAlpha', 0.6);
            scatter(x2, target_concentrations(i), 35, region_colors(2*p,:), ...
                'filled', 'MarkerFaceAlpha', 0.6);
            
            % Connect paired observations with gray lines
            plot([x1, x2], [MOp_concentrations(i), target_concentrations(i)], ...
                'k-', 'LineWidth', 0.4, 'Color', [0.4, 0.4, 0.4, 0.5]);
        end
    end
    
    % Add visual separators between pathways
    y_lim = [min(all_concentrations)*0.8, max(all_concentrations)*1.2];
    for p = 1:(n_pathways_found-1)
        separator_x = 2*p + 0.5;
        plot([separator_x, separator_x], y_lim, 'k:', ...
            'LineWidth', 1, 'Color', [0.6, 0.6, 0.6]);
    end
    
    % Add statistical significance annotations
    annotation_height = max(all_concentrations) * 1.05;
    
    for p = 1:n_pathways_found
        MOp_pos = 2*p - 1;
        target_pos = 2*p;
        
        stats = pathway_stats.(sprintf('pathway_%d', p));
        p_val = stats.p_value;
        
        % Draw significance bracket
        plot([MOp_pos, target_pos], [annotation_height, annotation_height], ...
            'k-', 'LineWidth', 1.2);
        
        % Add p-value with significance stars
        text((MOp_pos + target_pos)/2, annotation_height * 1.03, ...
            sprintf('p = %.3f%s', p_val, get_significance_stars(p_val)), ...
            'HorizontalAlignment', 'center', 'FontSize', 22, 'FontWeight', 'normal');
        
        % Add sample size
        text((MOp_pos + target_pos)/2, annotation_height * 0.93, ...
            sprintf('n = %d', stats.n_sessions), ...
            'HorizontalAlignment', 'center', 'FontSize', 20, 'FontWeight', 'normal');
    end
    
    % Configure axis labels
    ylabel('R^2 at 50% Neuron Removal', ...
        'FontSize', 30, 'FontWeight', 'normal');
    
    set(gca, 'FontSize', 25);
    grid on;
    set(gca, 'GridLineStyle', ':', 'GridAlpha', 0.6);
    ax = gca;
    ax.Box = 'off';
    
    if n_pathways_found > 3
        xtickangle(35);
    end
    
    ylim([min(all_concentrations) * 0.8, annotation_height * 1.20]);
    
    % Save outputs
    saveas(gcf, fullfile(output_dir, 'MOp_pathway_boxplot.png'));
    %saveas(gcf, fullfile(output_dir, 'MOp_pathway_boxplot.fig'));
    
    % Save comprehensive statistics
    comprehensive_stats = struct();
    comprehensive_stats.pathway_session_data = pathway_session_data;
    comprehensive_stats.pathway_stats = pathway_stats;
    comprehensive_stats.pathway_names = pathway_names;
    comprehensive_stats.test_type = 'Wilcoxon signed-rank test (paired observations)';
    
    save(fullfile(output_dir, 'MOp_pathway_paired_stats.mat'), 'comprehensive_stats');
    
    % Print statistical summary
    fprintf('\n=== MOp Pathway Paired Analysis Results ===\n');
    fprintf('Total Pathways: %d\n\n', n_pathways_found);
    
    for p = 1:n_pathways_found
        stats = pathway_stats.(sprintf('pathway_%d', p));
        fprintf('Pathway: MOp ↔ %s (n=%d sessions)\n', stats.name, stats.n_sessions);
        fprintf('  MOp:    %.3f ± %.3f (median: %.3f)\n', ...
            stats.MOp_mean, stats.MOp_std, stats.MOp_median);
        fprintf('  %s:  %.3f ± %.3f (median: %.3f)\n', ...
            stats.name, stats.target_mean, stats.target_std, stats.target_median);
        fprintf('  Δ(MOp - %s): %.3f\n', stats.name, stats.median_difference);
        fprintf('  Significance: p = %.4f %s\n\n', ...
            stats.p_value, get_significance_stars(stats.p_value));
    end
    
    fprintf('Analysis complete. Results saved to %s\n', output_dir);
end

% =========================================================================
% HELPER FUNCTIONS
% =========================================================================

function [is_MOp_pair, idx1, idx2] = check_MOp_pairing(region1, region2, all_regions)
% CHECK_MOp_PAIRING Determines if region pair involves MOp
%
% RETURNS:
%   is_MOp_pair - Boolean indicating MOp involvement
%   idx1, idx2  - Indices in all_regions array

    is_MOp_pair = false;
    idx1 = [];
    idx2 = [];
    
    % Check if either region contains MOp
    contains_MOp_1 = contains(region1, 'MOp', 'IgnoreCase', true);
    contains_MOp_2 = contains(region2, 'MOp', 'IgnoreCase', true);
    
    if ~contains_MOp_1 && ~contains_MOp_2
        return;
    end
    
    % Find indices in all_regions
    idx1 = find_region_index(region1, all_regions);
    idx2 = find_region_index(region2, all_regions);
    
    if ~isempty(idx1) && ~isempty(idx2)
        is_MOp_pair = true;
    end
end

function idx = find_region_index(region_name, all_regions)
% FIND_REGION_INDEX Locates region in standardized region list
%
% Handles naming variations and abbreviations

    idx = [];
    
    % Direct match
    for i = 1:length(all_regions)
        if strcmp(region_name, all_regions{i})
            idx = i;
            return;
        end
    end
    
    % Special handling for MOp
    if contains(region_name, 'MOp', 'IgnoreCase', true)
        idx = 1;
        return;
    end
    
    % Partial match (substring search)
    for i = 1:length(all_regions)
        if contains(region_name, all_regions{i}, 'IgnoreCase', true) || ...
           contains(all_regions{i}, region_name, 'IgnoreCase', true)
            idx = i;
            return;
        end
    end
end

function idx = find_MOp_pathway_index(region1, region2, MOp_pathways)
% FIND_MOp_PATHWAY_INDEX Identifies which MOp pathway a region pair represents
%
% INPUTS:
%   region1, region2 - Region identifiers
%   MOp_pathways     - Cell array defining MOp pathways
%
% RETURNS:
%   idx - Index in MOp_pathways, or empty if not an MOp pathway

    idx = [];
    for i = 1:size(MOp_pathways, 1)
        pathway_short = MOp_pathways{i, 2};
        
        if (contains(region1, 'MOp') && contains(region2, pathway_short, 'IgnoreCase', true)) || ...
           (contains(region2, 'MOp') && contains(region1, pathway_short, 'IgnoreCase', true))
            idx = i;
            return;
        end
    end
end

function color = get_pathway_color(pathway_name)
% GET_PATHWAY_COLOR Assigns consistent colors to pathways
%
% Color scheme based on functional neuroanatomy

    switch pathway_name
        case 'OLF'  % Olfactory
            color = [0.8, 0.4, 0.8];  % Purple
        case 'ORB'  % Orbital
            color = [0.2, 0.6, 0.2];  % Green
        case 'STR'  % Striatum
            color = [0.3, 0.5, 0.8];  % Blue
        case 'MOp'  % Secondary motor
            color = [0.8, 0.5, 0.2];  % Orange
        case 'mPFC' % Medial prefrontal
            color = [0.8, 0.2, 0.2];  % Red
        otherwise
            color = [0.5, 0.5, 0.5];  % Gray (default)
    end
end

function stars = get_significance_stars(p_value)
% GET_SIGNIFICANCE_STARS Converts p-values to conventional notation
%
% Thresholds: *** p<0.001, ** p<0.01, * p<0.05, n.s. otherwise

    if p_value < 0.001
        stars = ' ***';
    elseif p_value < 0.01
        stars = ' **';
    elseif p_value < 0.05
        stars = ' *';
    else
        stars = ' n.s.';
    end
end

% =========================================================================
% EXECUTION BLOCK: Run all MOp analyses with corrected file-based loading
% =========================================================================
fprintf('\n========================================\n');
fprintf('Beginning MOp-Focused Sensitivity Analysis\n');
fprintf('Data Source: %s\n', output_dir);
fprintf('========================================\n\n');

% Execute all three analysis functions
% All functions now properly load from sensitivity_*.mat files
create_MOp_regional_drop_heatmap(output_dir);
create_MOp_concentration_barplot(output_dir);
create_MOp_pathway_boxplot(output_dir);

fprintf('\n========================================\n');
fprintf('MOp analysis complete!\n');
fprintf('All results saved to: %s\n', output_dir);
fprintf('========================================\n');